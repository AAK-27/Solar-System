<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Horizons!</title>
		<style>
			body {
                margin: 0;
                color: aliceblue;
            }
            canvas {
                position: absolute;
                top: 0;
                left: 0;
                z-index: -1;
            }
		</style>
        <script type="importmap">
            {
              "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@v0.165/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.165/examples/jsm/"
              }
            }
          </script>
	</head>
	<body>
        <canvas></canvas>
        <script type="module">
          import * as THREE from 'three';
          import { FlyControls } from 'three/addons/controls/FlyControls.js';
          import Stats from 'three/addons/libs/stats.module.js';

          const DISTANCESCALE = 300; // The positions are saved in AU; the scale ignores the units, chaning AU -> m
          const SIZESCALE = 0.01 // Sizes are saved in km; the scale is a conversion factor to meters
          // Planets are scaled differently in the JSON to prevent overlap with the scaled distances

          const scene = new THREE.Scene();
          const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
          
          const renderer = new THREE.WebGLRenderer();
          renderer.setSize( window.innerWidth, window.innerHeight );
          document.body.appendChild( renderer.domElement );

          const stats = new Stats();
          document.body.appendChild( stats.dom );

          const controls = new FlyControls(camera, renderer.domElement);
          controls.movementSpeed = 20;
          controls.rollSpeed = Math.PI / 4;
          controls.autoForward = false;
          controls.dragToLook = true;
          
          camera.position.z = 1000;
          
          const light = new THREE.DirectionalLight( 0xffffff, 1);
          light.position.set(0, 0, 2);
          scene.add( light );
          
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
          scene.add( ambientLight );
          
          const redLineMaterial = new THREE.LineBasicMaterial( { color: 0xff0000 } );
          const greenLineMaterial = new THREE.LineBasicMaterial( { color: 0x00ff00 } );
          const blueLineMaterial = new THREE.LineBasicMaterial( { color: 0x0000ff } );
          
          const xAxisPoints = [];
          xAxisPoints.push( new THREE.Vector3( 10, 0, 0 ) );
          xAxisPoints.push( new THREE.Vector3( 0, 0, 0 ) );
          const xAxisGeometry = new THREE.BufferGeometry().setFromPoints( xAxisPoints );
          const xAxis = new THREE.Line( xAxisGeometry, redLineMaterial );
          scene.add( xAxis );
          
          const yAxisPoints = [];
          yAxisPoints.push( new THREE.Vector3( 0, 10, 0 ) );
          yAxisPoints.push( new THREE.Vector3( 0, 0, 0 ) );
          const yAxisGeometry = new THREE.BufferGeometry().setFromPoints( yAxisPoints );
          const yAxis = new THREE.Line( yAxisGeometry, greenLineMaterial );
          scene.add( yAxis );
          
          const zAxisPoints = [];
          zAxisPoints.push( new THREE.Vector3( 0, 0, 10 ) );
          zAxisPoints.push( new THREE.Vector3( 0, 0, 0 ) );
          const zAxisGeometry = new THREE.BufferGeometry().setFromPoints( zAxisPoints );
          const zAxis = new THREE.Line( zAxisGeometry, blueLineMaterial );
          scene.add( zAxis );
          
          fetch('all_bodies.json')
            .then(response => response.json())
            .then(data => {
                const planets = ['10', '199', '299', '399', '499', '599', '699', '799', '899'];
                for (let keys in data){
                    if (planets.includes(keys)){
                      // console.log(data[keys].position);
                      const diameter = data[keys].diameter;
                      // const color = data[keys]["color"];
                      const position = data[keys].position;
                      const bodyGeometry = new THREE.SphereGeometry( diameter * SIZESCALE );
                      const color = data[keys].color;
                      console.log(color);
                      const threeColor = new THREE.Color();
                      threeColor.setRGB(color[0], color[1], color[2])
                      const material = new THREE.MeshStandardMaterial({ color: threeColor });
                      const body = new THREE.Mesh( bodyGeometry, material );
                      body.position.set(position[0]*DISTANCESCALE, position[2]*DISTANCESCALE, position[1]*DISTANCESCALE);
                      scene.add( body );
                      continue;
                    }
                    // console.log(data[keys].position);
                    const diameter = data[keys].diameter;
                    // const color = data[keys]["color"];
                    const position = data[keys].position;
                    const bodyGeometry = new THREE.SphereGeometry( diameter * SIZESCALE );
                    const material = new THREE.MeshStandardMaterial();
                    const body = new THREE.Mesh( bodyGeometry, material );
                    body.position.set(position[0]*DISTANCESCALE, position[2]*DISTANCESCALE, position[1]*DISTANCESCALE);
                    scene.add( body );
                }
            });
          
          function animate() {
            controls.update(0.01);
            stats.update();
            renderer.render( scene, camera );
          }
          
          renderer.setAnimationLoop( animate );
        </script>
	</body>
</html>